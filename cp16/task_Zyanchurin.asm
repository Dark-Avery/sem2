include console.inc

COMMENT ~

САМОСТОЯТЕЛЬНАЯ РАБОТА 16
СТУДЕНТ Зянчурин Игорь    группа 110

~
COMMENT~ 
----------------------------------------------------------------------------
ВНИМАНИЕ: ВСЕ ИСПОЛЬЗУЕМЫЕ ОПИСАНИЯ ПЕРЕМЕННЫХ и КОНСТАНТ ДАЮТСЯ В СЕКЦИИ
ДАННЫХ ЭТОЙ ПРОГРАММЫ !!!
---------------------------------------------------------------------------- 
 ЗАДАЧА (максимально 60 очков), время выполнения 90 минут
 
 Описать функцию Search(Str1,Str2,n,k), где Str1 и Str2 - символьные строки
 фиксированной длины из n (n>0) символов каждая, k - число из диапазона 
 от 1 до n. Функция определяет, входят ли первые k символов строки Str2 
 в строку Str1 как ПОДСТРОКА. 
 Если ДА, то возвращает через регистр EAX номер позиции (в Str1), начиная 
 с которой найдено первое вхождение ПОДСТРОКИ (позиции нумеруются с НУЛЯ!).
 Если НЕТ, то возвращает через ЕАХ ответ -1 (минус единицу).
 
 Требования. 
 ----------
 1) Параметры Str1 и Str2 должны быть переданы по ссылке, параметры n и k - 
 по значению (+ cтандартные соглашения о связях stdcall).
  
 2) Применить функцию Search(Str1,Str2,n,k) к следующим данным:
 Search(S1,S2,n,k)
 (описание имён S1, S2, n и k приведено ниже в секции данных)
 Значение для k следует предварительно ввести с клавиатуры.
 Найденное значение индекса (которое возвращается через ЕАХ) - 
 напечатать из основной программы после вызова функции Search
 
 3) Требование: в решении использовать команду cmpsb в паре с нужным 
 префиксом повторения для поиска подстроки (при очередной попытке). 
 
 См. КОММЕНТАРИЙ в конце (после директивы end) про УПРОЩЁННУЮ ПОСТАНОВКУ
 этой задачи, но на 30 очков (если в ИСХОДНОЙ ПОСТАНОВКЕ задачу решить сложно)
  
 Примеры работы программы для S1 и S2 с описанными (в .data) значениями
 (для тестирования процедуры Search):
 k = 1   i = 0
 k = 2   i = 0
 k = 3   i = 2
 k = 4   i = 5
 k = 5   i = 9
 k = 6   i = 17
 k = 11  i = 17
 k = 28  i = -1
 Здесь значение для k запрашивается программой и вводится с клавиатуры, 
 значение для i (индекса вхождения) - вычисляется и печатается на экран.

Отправить НА ПРОВЕРКУ в следующем виде:
Если программа доведена до работоспособного состояния (выдаёт правильные
результаты, как в вышеприведённых тестах) - прислать zip-архив с файлами: 
asm, lst и exe по этой программе + СКРИНШОТ ЭКРАНА с результатами работы
вашей программы на всех вышеприведённых тестах. Если же программа не работает
или не дописана до конца - поместить в архив только файл Task_sername.asm.
Внимание! Замените в названии файла слово Sername на свою фамилию на 
английском языке. Если вы решили задачу в исходной постановке, то ничего
не меняйте в строке 67 (где определена переменная Т). Если вы решили задачу
в упрощённой постановке, то  укажите какой УПРОЩЁННЫЙ вариант вы сдаёте.
~
.data
T   db  "Задача (с-р 16) Зянчурин 110 (ИСХОДНАЯ постановка)",0

S1  db "ababcabcdabcdelmnabcdefghijk"
S2  db "abcdefghijklmnopqrstuvwxyzab"

n   equ ($-S2)                ; длина одной строки (=28)
k   db ?                      ; длина искомой подстроки (1..n)

.code
; procedure Search(var Str1, Str2: array of byte; n, k: longword)
Search proc
;   [EBP+8]  - адрес Str1
;   [EBP+12] - адрес Str2
;   [EBP+16] - значение n
;   [EBP+20] - значение k
;   ДАЛЕЕ ВАШЕ РЕШЕНИЕ 
    push EBP
    mov EBP, ESP
    push ECX
    push EDX
    push EDI
    push ESI
    
    mov EDI, [EBP+8]
    mov ESI, [EBP+12]
    mov ECX, [EBP+16]
    mov EDX, [EBP+20]
    
    sub ECX, EDX        
    inc ECX         ; max первый элемент
    
    xor EAX, EAX
    cld
    
@L: push ESI
    push EDI
    xchg ECX, EDX
    push ECX
repE cmpsb
    pop ECX
    xchg ECX, EDX
    pop EDI
    pop ESI
    jz @F
    inc EAX
    inc EDI
    loop @L
    
    mov EAX, -1
    
@@: pop ESI
    pop EDI
    pop EDX
    pop ECX
    pop EBP
    ret 4*4
Search endp
 
Start:
    ConsoleTitle offset T	
    ; считать, что значение для k будет введено корректно (от 1 до n)
    inint k,"k = "
    
    
; ДАЛЕЕ ПРИМЕНЕНИЕ ВАШЕЙ ПРОЦЕДУРЫ (в соответствие с выбранной постановкой):
; НЕ ЗАБУДЬТЕ В СТРОКЕ 67 УКАЗАТЬ (В СКОБКАХ) КАКАЯ ПОСТАНОВКА ЗАДАЧИ ВЫБРАНА
    movzx EBX, k
    push EBX
    push n
    push offset S2
    push offset S1
    call Search
    outintln EAX,,'i = '
    
; ЕСЛИ ПРОГРАММА РАБОТАЕТ ВЕРНО, НЕ ЗАБУДЬТЕ ПОМЕСТИТЬ В АРХИВ СКРИНШОТЫ 
; РЕЗУЛЬТАТОВ РАБОТЫ ПРОГРАММЫ ПО ВСЕМ ТЕСТАМ (СТРОКИ 44-51) 
    pause						; нужно при сдаче по e-mail
    exit						
end Start
-------------------------------------------------------------------
КОММЕНТАРИЙ (упрощённая постановка задачи - на 30 очков вместо 60):
-------------------------------------------------------------------
Упрощённый вариант_1:
Если сложно вычислить индекс первого вхождения, то можно дать ответ в 
более простом варианте:
Если ДА (входит), то возвращает через регистр EAX значение 0 (ноль).
Если НЕТ (не входит), то возвращает через ЕАХ ответ -1 (минус единицу).
Указать (обязательно!) в строке 67 при описании переменной Т, что 
выбрана более простая постановка задачи в упрощённом варианте_1
(для облегчения проверки). 
-------------------------------------------------------------------
Упрощённый вариант_2:
Если не знаете как использовать команду cmpsb в паре с нужным префиксом
повторения для поиска подстроки (при очередной попытке), то решайте как 
можете (без строковых команд), но тогда за это максимум 30 очков.
Указать (обязательно!) в строке 67 при описании переменной Т, что 
выбрана более простая постановка задачи в упрощённом варианте_2
(для облегчения проверки). 
-------------------------------------------------------------------


 