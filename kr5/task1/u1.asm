comment ~

ВЫХОД-5 (Задача_1, вспомогательный модуль)

Написать программу из двух модулей. 

В головном модуле описать двойное слово  X (содержимое которого
трактуется как число без знака) и байт Res (содержимое которого
трактуется как число со знаком).  

Во вспомогательном  модуле описать  общедоступную процедуру 
Power2(X,Res) со стандартными соглашениями о связях  (stdcall).
Параметр  X передаётся в процедуру по значению, Res – по ссылке.
Процедура Power2 выполняет проверку 32-битной беззнаковой величины Х:
является ли она степенью двойки, т.е. существует ли такое  k: 
от 0 до 31, что X=2^k. Если да, то процедура записывает в байт Res
показатель k найденной степени двойки, иначе – записывает в байт Res
 -1 (минус!). В процессе своей работы процедура не использует команды
умножения и деления. 

Головной модуль вводит значение переменной Х,  после чего обращается
к внешней процедуре Power2(X,Res)  для проверки числа X.  Затем 
головной модуль выводит в окно консоли полученный в Res ответ. 
На этом работа двухмодульной программы 
завершается.

Подсказка: в двоичном представлении степень двойки выглядит как 
000…010…00, начальная или конечная последовательность нулей может
отсутствовать.  При проверке числа Х рекомендуется использовать 
маску вида 000…010…00 с подвижной единицей (передвигающейся от 
одного края маски до другого), а также команду xor для сравнения
битового представления числа Х  с данной маской (командами cmp и 
sub для сравнения с маской - не пользоваться!).  

Тесты:   
1  -> 0,       2  -> 1,      5  -> -1,      256  -> 8,     65536  -> 16,      
65535  > -1,    1048576  > 20,   2147483648   > 31,     4000000000  > -1   

~

;---------------------------------------------------------------------
;            ВСПОМОГАТЕЛЬНЫЙ МОДУЛЬ (далее ваше решение:)
;---------------------------------------------------------------------
include console.inc

.code
    Power2 proc public
        push EBP
        mov EBP,ESP
        push EAX
        push EBX
        push ECX
        push EDX
        push EDI
        
        mov EBX, [EBP+8]
        mov EDX, [EBP+12]


        xor cl,cl
        mov EDI, 1
        
@L:     mov EAX,EBX
        xor EAX, EDI
        jz @next
        inc cl
        shl EDI, 1
        jnc @L
        
        mov cl, -1

@next:  mov [EDX], CL
        
        pop EDI
        pop EDX
        pop ECX
        pop EBX
        pop EAX
        pop EBP
        ret 4*2
    Power2 endp
    
    end


;---------------------(конец вашего решения)--------------------------
    

